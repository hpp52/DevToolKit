### Redis Persistence
> Redis 的数据都保存在内存中，如果不开启持久化
>
> 当发生服务器宕机或其他灾难，数据将会永久丢失
>
> Redis 提供两种持久化方案 - **RDB** 与 **AOF**


#### RDB(快照)
###### 概念：
  **R**edis **D**ata **B**ase，是一次全量备份，对内存数据的二进制序列化

###### 快照实现：

  Redis在持久化时调用glibc的函数fork产生一个子进程进行快照持久化，父进程继续处理客户端请求

  Redis使用操作系统的多进程 COW(Copy On Write)机制来实现持久化， 数据段由很多操作系统的页面组合而成

  - 子进程

      子进程刚产生时，与父进程共享内存的代码段和数据段。不会修改现有的内存数据结构，只对数据结构遍历读取，再序列化写入磁盘

  - 父进程

      在给客户端提供服务时，不间断的对内存数据修改。为了避免持久化的冲突，在修改其中一个页面时，会将其页面复制一份，对这个复制出来的页面进行修改

###### 相关配置
  1. save 100 1：在100秒内至少有1个key改变时，同步到磁盘
  2. rdbcompression yes：消耗部分CPU压缩数据，默认为yes
  3. dir ./ ：配置RDB和AOF文件的存储目录

###### 优点：
  1. 备份版本紧凑，可以根据时间节点重启不同的数据版本
  2. 对于灾难恢复表现优秀，可保存到远程数据中心
  3. 对Redis性能的影响低，使用子进程完成持久化，父进程不产生磁盘IO
  4. 使用RDB重启Redis比AOF更快

###### 缺点
  1. 灾难恢复时无法降低数据丢失
  2. 持久化时子进程fork()频繁，数据量大时，持久化需要的时间长，会导致Redis短时间内停止服务(n ms ~ 1s)

#### AOF

###### 概念：**A**pend **O**nly **F**ile，是连续的增量备份，记录下了修改内存数据的指令

###### AOF实现：

  Redis收到客户端的写指令后，进行参数校验，通过校验后立即将指令存储到AOF中（在执行指令之前先记录进磁盘）。可对一个空的Redis实例顺序执行AOF中的所有命令，来恢复Redis的内存数据结构。随着Redis的不断运行，AOF日志会越来越长，需要进行重写

  Redis针对安全性和性能的取舍提供了3种策略：
    - appendonlysync no：不主动同步，依赖操作系统进行fsync，在Linux中一般为30s
    - appendonlysync everysec：每秒进行一次同步，性能适中
    - appendonlysync always：每一次操作都进行一次同步，性能最低

###### 优点：
  1. AOF的一致性更优秀，甚至可以实现同步每一次的写请求
  2. AOF是一种append-ony log，服务器发生意外情况时不会使整个文件浪费，可通过工具修复只写到一半的命令
  3. 在AOF过大时支持后台自动重写，重写不影响继续追加
  4. 拥有可读性，意外操作FLUSHALL时，可移除掉最后一条命令再重启Redis

###### 缺点
  1. 比RDB文件更大
  2. 重启时比RDB加载更慢
  3. 稳定性不够，由于是增量更新，bug不易排查，不如RDB健壮
  
###### AOF重写
使用bgrewriteaof重写AOF。执行时创建子进程对内存进行遍历转换成一系列Redis的操作指令，序列化写入新的AOF中。完成后再将重写期间发生的操作增量追加到新AOF中，追加完毕后替换掉旧的AOF文件.

###### 相关配置：
  - appendonly yes：打开AOF持久化
  - appendfsync everysec：持久化策略 - 每秒同步一次（性能适中，最坏丢失1s的数据）
  - auto-aof-rewrite-percentage 100：重写的阈值-aof文件大小增长的百分比
  - auto-aof-rewrite-min-size：重写的阈值-aof文件大小

#### Redis4.0混合持久化
持久化痛点：RDB持久化不够安全，而AOF性能不如RDB优秀.

在Redis4.0后，支持 *混合持久化* :

使用RDB进行快照全量备份，再使用AOF记录RDB持久化开始-结束这段时间的修改操作增量日志。在重启Redis时，先加载RDB内容，再加载AOF的命令，就能保证性能的同时获得更高的安全性.

---

### Redis - Replication
> Redis 同步是集群的基础。先简单了解一下什么是 **CAP**
>
> **CAP定理**：Consistent(强一致性),Availability(可用性),Partition tolerance(分区容错性)
>
> 三者不可同时拥有。网络分区发生时，一致性和可用性难两全。
>
> Redis集群必须满足分区容错性，对于一致性和可用性的选择：当主从网络断开时，主节点正常对外提供服务，舍弃强一致性，保证集群的可用性，在网络恢复后，再进行主从同步，实现**弱一致性**。

#### 主从同步的实现

###### Replication ID 和 offset(偏移量)：

每一个Redis主机都有自己的Replication ID和offset，用来标识一个主机的一个数据库的一个版本，主从同步时会匹配Replication ID 和offset

ID用来标记(识别)数据库。ID会在两种情况下发生改变：master重启时/slave晋升时

slave与master连接后会继承master的ID

实例有两个Replication ID：main ID 和 secondary ID

当slave晋升时，会保留原主机的ID，并产生新ID

- 为什么要产生新ID呢？  - 保证ID+offset标识唯一的数据版本
- 为什么要保留原主机ID呢？ - 其他从机在下一次同步时，会与(新)主机的ID进行匹配，如果不产生新ID，故障恢复后，其他从机只能进行全量同步，增加不必要的负担

###### 增量同步

  主机会把对自己的状态产生影响的操作记录到本地的内存buffer(定长的环型数组)，并异步将buffer中的指令同步给从节点，从节点执行指令，同时更新自己的offset。

###### 全量同步

  将当前内存中的数据全量生成RDB文件，再将RDB文件传送给从节点。从节点接受完毕后，清空当前内存中的数据，并全量加载RDB。完成后继续进行增量同步。但如果这个步骤耗时过长或者缓存设置过小，将造成死循环继续进行全量同步。

> 当Replication ID不一致 -> 全量同步
>
> 当新增一个从节点时 -> 全量同步
>
> 当offset差值大于主机的缓存量 -> 全量同步
>
> 当offset差值不大于主机的buffer -> 增量同步

###### 同步流程：
1. 主机启动后台进程制造RBD文件，并缓存此时的所有写请求
2. 主机向从机发送RDB文件，从机保存在磁盘中，再加载到内存中
3. 主机将之前缓存的写命令发送给从机
4. 更新完成

###### 注意：
  1. 实例之间的数据同步是异步进行的
  2. 一台主机可有多个从机
  3. 从机之间允许同通信，也可进行从从同步，但保证数据与主机保持同步
  4. 从主机角度看，同步是非阻塞进行的，在同步时可处理其他读写请求
  5. 从从机角度看，同步大部分工作也是非阻塞的，通过配置，允许从机在同步过程中处理请求。但是在替换老数据库时会阻塞连接。Redis4.0后通过配置，使用不同的线程删除老数据库，但载入新数据库的工作在主线程上执行，并阻塞从机。
  6. 同步具有伸缩性，可提升数据的安全性和可用性，还可以让从机完成复杂度高的只读操作
  7. 关闭主机持久化可以降低主机的资源消耗，从安全性考虑，建议同时开启主、从的持久化，至少把从机配置为*avoid restarting automatically* 禁止从机跟随主机重启。

###### 从机只读：

为了提高数据的安全性，Redis2.6版本后从机可设置为只读

如果在从机写入数据，从机会在重同步或重启时丢失数据

Redis 4.0后从机的写入操作都是本地的，不会在集群传播

A(主) -> B(从) -> C(从) ，在B写入时，C仍然会与A保持同步

###### 一致性：对过期key的处理

1. 从机不会在key到期后expire，只会通过与主机同步的方式刷新数据库
2. 从机的key到期后，在主机还没有与从机更新前，从机上的该key不可读(从机用自己的计时器对过期key拒绝读取，此时该key仍然存在)
3. 在执行脚本时，会停止key的计时，并把脚本发送给从机

*注：当从机晋升时，将有能力expire key,不需要依赖旧主机来刷新掉这个key*

#### 配置
```
slaveof <ip><port>：配置从服务器的主机ip和端口
masterauth <password>：当主机开启了密码认证时需要配置
slave-serve-stale-data yes/no：当与主机失去通信时，是否回复请求
    yes：可能有过时数据/空数据 no：只回应INFO和SLAVEOF命令，其他命令全拒绝
slave-read-only yes：从机只读，这样可以更加保证数据的安全性和一致性
repl-diskless-sync yes：主从同步的方式选择
  - Disk-backed：基于磁盘的同步。
    主机创建子进程把RDB写入磁盘，再将RDB文件传给从机，效率受磁盘限制
  - Diskless：无磁盘同步。
    主机创建子进程将命令通过socket发送给从机，效率受网络环境限制
repl-diskless-sync-delay 5：启用Diskless同步时，延迟等待其他需要同步的从机一起传输
repl-ping-slave-period 10：从机发送心跳的时间间隔
repl-timeout 60：timeout要比心跳间隔长。timeout发生的情况：
  - 从机角度：同步时的I/O太大 或者 主机超时
  - 主机角度：从机超时
slave-priority 100：从机选举优先级，数越小优先级越高。0表示不参与选举
min-slave-to-write 3 min-slave-max-lag 10：当从机数量少于3个、网络延迟大于10s，
    不接受写请求（牺牲高可用性换取数据的安全性）
slave-announce-ip 10.0.0.127 slave-announce-port 6379：
    当使用Docker之类的容器部署从机时，master收到的ip和端口可能与
    从机的逻辑地址有出入，在使用容器的时候需要注意。
```
